//
//  GameScreenController.m
//  MindBlaster
//
//  Created by Steven Verner on 2/21/10.
//  Copyright 2010 __MyCompanyName__. All rights reserved.
//

#import "GameScreenController.h"
#import "GameOverScreenController.h"
#import "HelpScreenController.h"
#import "Ball.h"

@implementation GameScreenController

@class asteroidClass;

@synthesize shipIcon;
@synthesize ship;

@synthesize asteroid0, asteroid1, asteroid2, asteroid3, asteroid4, asteroid5, asteroid6, asteroid7, asteroid8, asteroid9;
@synthesize asteroids;  //this is the vector which will hold all of the above asteroid objects

@synthesize rotationBall;

@synthesize bullet0, bullet1, bullet2, bullet3, bullet4, bullet5;
@synthesize bullets; //this is the vector which will hold all of the above bullet objects

@synthesize question;
@synthesize questionLabel;
@synthesize solution0,solution1,solution2,solution3,solution4,solution5;
@synthesize solutions; //this is the vector which will hold all of the above solution objects

@synthesize scoreLabel;

// DEFINED CONSTANTS
const int CORRECT_ASTEROID = 0;
const int INCORRECT_ASTEROID = 1;
const int BLANK_ASTEROID = 2;

//  Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
- (void)viewDidLoad {
	
	// create game objects
	ship = [[Ship alloc] init];				// create the ship object
	[ship setIcon: shipIcon];				// connect the ship icon to the Ship object so it can be rotated
	//[self setQuestion];						// set the initial question
	
	// set the score initially to 0
	score = 0;  
	
	
	
	//int i;  //used as a counter 
	int firstOperand, secondOperand, wrongAnswer;

	//first two operands of question are generated by the rand() random number generator
	srand(clock());			//random number generator is initialized by the clock
	firstOperand = rand()%10;	
	secondOperand = rand()%10;
		
	//question string is generated and displayed from the two previously randomly generated operands
	NSString *InputString = [[NSString alloc] initWithFormat:@"%d + %d = ??", firstOperand, secondOperand];
	[questionLabel setText:InputString];
	[InputString release];
	
	//allocate memory for an asteroidClass object to the previously initialized asteroidClass object, asteroidDetailsTemp
	asteroidDetailsTemp = [[asteroidClass alloc] init];
	
	//values used to describe the direction the ship is facing, derived from the rotation wheel
	shipDirectionX = 0;  
	shipDirectionY = -15;
	//NSLog(@"Post load:   shipX = %f,   shipY = %f", shipDirectionX, shipDirectionY);
	
	//incrementor which denotes the next bullet to be fired, the 0th bullet is fired first
	bulletsFired = 0;
	
	//define image arrays to hold the their respective images (which are pre-assigned in the interface builder)
	asteroids = [[NSMutableArray alloc] initWithObjects: asteroid0,asteroid1,asteroid2,asteroid3,asteroid4,asteroid5,asteroid6,asteroid7,asteroid8,asteroid9,nil];
	bullets = [[NSMutableArray alloc] initWithObjects: bullet0,bullet1,bullet2,bullet3,bullet4,bullet5,nil];
	solutions = [[NSMutableArray alloc] initWithObjects: solution0,solution1,solution2,solution3,solution4,solution5];
	
	//sets the initial movement vectors
	for(int i = 0; i < 10; i++)
	{
		do{
			
			[asteroidDetailsTemp setAsteroidDirection:((random() %30 ) / 5  -3) :((random() % 30) / 5 -3)];
			if(i == 0)
				[asteroidDetailsTemp setAsteroidType:CORRECT_ASTEROID];
			else if(i < 6)
				[asteroidDetailsTemp setAsteroidType:INCORRECT_ASTEROID];
			else 
				[asteroidDetailsTemp setAsteroidType:BLANK_ASTEROID];
			
		}while( asteroidDetailsTemp.asteroidDirection.x == 0 || asteroidDetailsTemp.asteroidDirection.y == 0 );
			
		asteroidDetails[i] = *asteroidDetailsTemp;
		NSLog(@"INIT asteroidType = %d", asteroidDetailsTemp.asteroidType);
	}


	
	UIImageView *tempBullet;  //temperary UIImageView allows manipulation of the elements of the bullets array
	for(int i = 0; i < 6;  i++)
	{
		tempBullet = [bullets objectAtIndex:i];
		tempBullet.center = CGPointMake(0,500); //set all bullets starting location as off-screen so they don't destroy any asteroids yet
	}
	[NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];
	
	//set the initial value of the solution asteroid
	UILabel *tempSolution = [solutions objectAtIndex:0];
	InputString = [[NSString alloc] initWithFormat:@"%d", (firstOperand + secondOperand) ];
	[tempSolution setText:InputString];
	
	//sets all the incorrect solution asteroids to have random values between (firstOperand + 1) and (firstOperand + 1 + secondOperand +3)
	for(int i = 1; i < 6; i++)
	{
		do{
			wrongAnswer = (firstOperand + 1 + random() % (secondOperand + 3));
		}while(wrongAnswer == (firstOperand + secondOperand));  
		// an incorrect solution asteroid is not allowed to have the value of the correct solution
			
		tempSolution = [solutions objectAtIndex:i];
		InputString = [[NSString alloc] initWithFormat:@"%d", wrongAnswer];
		[tempSolution setText:InputString];
	}
	
    [super viewDidLoad];
}


-(IBAction) FireButton{
	UIImageView *tempBullet; //temperary UIImageView allows manipulation of the elements of the asteroids array
	
	tempBullet = [bullets objectAtIndex:bulletsFired]; 
	//assigns element of bullets array to tempBullet to allow manipulation of that element
	
	//sets the bullet being fired's movement vector to the vector defined by the direction in which the ship is pointing
	bulletPos[bulletsFired] = CGPointMake(shipDirectionX,shipDirectionY); 

	tempBullet.center = CGPointMake(242,167);
	tempBullet.hidden = NO; 
	
	if(bulletsFired == 5)   //there are only six bullets so once all 6 have been fired start at 0 again
		bulletsFired = 0;
	else
		bulletsFired++;
}

// sets the label for the question according to the profile settings
-(IBAction)setQuestion {
	question = [[Question alloc] init];						// create a new question object
	question.questionLabelOutletPointer = questionLabel;	// connect the local outlet to the object outlet
	
	// collect state information from profile settings
	int difficulty = 1;										// should get difficulty from the profile (for now set to 1)	// (profile)
	NSString *topic = @"+" ;								// get topic from profile (for now set to + )					// (profile)
	
	[question setQuestion:topic difficulty:difficulty];		//set the question
	[question generateCorrectAnswer];
}

//this function is called every 0.05 seconds, and updates the game screen
-(void) onTimer {

	int asteroidXSize = 32;
	int asteroidYSize = 30;
	int wrongAnswer;
	
	UIImageView *tempAsteroid;
	UIImageView *tempBullet;
	UILabel *tempSolution;
	
	int firstOperand, secondOperand;
	
	
	//updates asteroid movement for each of the 10 asteroids, 0-9
	for(int i = 0; i <= 9; i++)
	{
		tempAsteroid = [asteroids objectAtIndex:i];
		*asteroidDetailsTemp = asteroidDetails[i];
		//CGPoint asteroidDirection = [asteroidDetailsTemp getAsteroidPoint]
		
		//moves asteroid
		tempAsteroid.center = CGPointMake(tempAsteroid.center.x + asteroidDetailsTemp.asteroidDirection.x, 
										  tempAsteroid.center.y + asteroidDetailsTemp. asteroidDirection.y);
		
		//if asteroid is either a correct solution asteroid or an incorrect solution asteroid move its solution label along with the asteroid
		if(i < 6)  
		{
			tempSolution = [solutions objectAtIndex:i];
			tempSolution.center = tempAsteroid.center;
		}
		
		//bounces asteroid if asteroid hits left or right of screen
		if( (tempAsteroid.center.x > 480 -asteroidXSize / 2 && (asteroidDetailsTemp.asteroidDirection.x > 0) )
		   || ( tempAsteroid.center.x < (0 +asteroidXSize / 2)   && (asteroidDetailsTemp.asteroidDirection.x < 0)) )
		{
			[asteroidDetailsTemp setAsteroidDirection: -asteroidDetailsTemp.asteroidDirection.x :asteroidDetailsTemp.asteroidDirection.y];
		}
		
		//bounces asteroid if asteroid hits top or bottom of screen
		if( (tempAsteroid.center.y > 293 -asteroidYSize / 2  && asteroidDetailsTemp.asteroidDirection.y > 0)
		   || (  tempAsteroid.center.y < (0 + asteroidYSize / 2)  && asteroidDetailsTemp.asteroidDirection.y < 0) )
		{
			[asteroidDetailsTemp setAsteroidDirection: asteroidDetailsTemp.asteroidDirection.x : -asteroidDetailsTemp.asteroidDirection.y];
		}
		asteroidDetails[i] = *asteroidDetailsTemp;
	}
	
	//updates the bullet movement for each of the 6 bullets and checks for collisions with asteroids 
	//in which case both bullet and asteroid are destroyed
	for(int i = 0; i <= 5; i++)
	{

		tempBullet = [bullets objectAtIndex:i];
		
		//moves bullet
		tempBullet.center = CGPointMake(tempBullet.center.x+bulletPos[i].x,tempBullet.center.y+bulletPos[i].y);
		
		//if bullet is off-screen then destroy the bullet by setting its movement to 0 and setting its location to 0,500, far off screen,
		//and finally hiding the bullet
		if( (tempBullet.center.x > 486 )|| ( tempBullet.center.x < -6 ) || (tempBullet.center.y > 300 )|| ( tempBullet.center.y < -6 ))
		{
			bulletPos[i].x = 0;
			bulletPos[i].y = 0;
			tempBullet.center = CGPointMake(0,500);
			tempBullet.hidden = YES;
		}
		
		//checks if the current bullet has collided with any of the 10 asteroids on the screen
		for( int j = 0; j <= 9; j++)
		{
			tempAsteroid = [asteroids objectAtIndex:j];
			
			//if there is a collision then destroy both asteroid and bullet, hide the bullet and move it off screen and
			//move the asteroid to just above and to the left of the screen so it can move back into the screen area
			//as a new asteroid
			if(  ((tempBullet.center.x < tempAsteroid.center.x + 20) && (tempBullet.center.x > tempAsteroid.center.x - 20))
			     &&((tempBullet.center.y < tempAsteroid.center.y + 20) && (tempBullet.center.y > tempAsteroid.center.y - 20)) )
			{
				tempAsteroid.center = CGPointMake(-10,-10);
				tempBullet.center = CGPointMake(0,500);
				tempBullet.hidden = YES;
				bulletPos[i] = CGPointMake(0,0);
				
				//if([asteroidDetailsTemp getAsteroidType]  == 0)  //correct score asteroid is shot
				if(j == 0)
				{
					score += 10;
					tempSolution = [solutions objectAtIndex:j];
					tempSolution.center = tempAsteroid.center; 
					 
					firstOperand = random() % 10;	
					secondOperand = random() % 10;
					
					//question string is generated and displayed from the two previously randomly generated operands
					NSString *InputString = [[NSString alloc] initWithFormat:@"%d + %d = ??", firstOperand, secondOperand];
					[questionLabel setText:InputString];
					[InputString release];
					
					InputString = [[NSString alloc] initWithFormat:@"%d", (firstOperand + secondOperand) ];
					[tempSolution setText:InputString];
					[InputString release];
					
					InputString = [[NSString alloc] initWithFormat:@"Score: %d", score ];
					[scoreLabel setText:InputString];		
					NSLog(@"CORRECT:    input string = %@", InputString);
					NSLog(@"INIT asteroidType = %d", asteroidDetailsTemp.asteroidType);
					NSLog(@"score = %d", score);
					
					
					for(int k = 1; k < 6; k++)
					{
						do{
							wrongAnswer = (firstOperand + 1 + random() % (secondOperand + 3));
							
						}while(wrongAnswer== (firstOperand + secondOperand));  
						//a incorrect solution asteroid is not allowed to have the value of the correct solution
						
						tempSolution = [solutions objectAtIndex:k];
						InputString = [[NSString alloc] initWithFormat:@"%d", wrongAnswer];
						[tempSolution setText:InputString];
						
						tempAsteroid = [asteroids objectAtIndex:k];
						tempAsteroid.center = CGPointMake( random() % 500-50, random() % 300-20 );
						
					}
					
					break;
				}
				//else if( [asteroidDetailsTemp getAsteroidType]  == 1 ) //incorrect score asteroid is shot
				else if(j < 6)
				{
					tempSolution = [solutions objectAtIndex:j];
					tempSolution.center = tempAsteroid.center; 
					score -= 2;
					NSString *InputString = [[NSString alloc] initWithFormat:@"Score: %d", score ];
					NSLog(@"WRONG:     input string = %@", InputString);
					NSLog(@"INIT asteroidType = %d", asteroidDetailsTemp.asteroidType);
					NSLog(@"score = %d", score);
					[scoreLabel setText:InputString];					
				}
				else	//blank asteroid is shot
				{
					score++;
					
					NSString *InputString = [[NSString alloc] initWithFormat:@"Score: %d", score ];
					[scoreLabel setText:InputString];
					NSLog(@"BLANK:    input string = %@", InputString);
					NSLog(@"INIT asteroidType = %d", asteroidDetailsTemp.asteroidType);
					NSLog(@"score = %d", score);
				}
					
			}
		}
	}
	
}

-(IBAction) HelpScreen
{
	// Navigation logic may go here -- for example, create and push another view controller.
	HelpScreenController *helpView = [[HelpScreenController alloc] initWithNibName:@"HelpScreenController" bundle:nil];
	[self.navigationController pushViewController:helpView animated:YES];
	[helpView release];
}
-(IBAction) NextScreen
{
	// Navigation logic may go here -- for example, create and push another view controller.
	GameOverScreenController *gamesOverScreenView = [[GameOverScreenController alloc] initWithNibName:@"GameOverScreenController" bundle:nil];
	[self.navigationController pushViewController:gamesOverScreenView animated:YES];
	[gamesOverScreenView release];
}

/*
// rotate ship according to rotation wheel angle
-(IBAction) rotateByAngle:(CGFloat)angle {
	ship.transform = CGAffineTransformMakeRotation(angle);
}
 */


/*This function is called when a touch on the screen is first detected
 */
-(void) touchesBegan: (NSSet *) touches withEvent: (UIEvent *) event {
	
    UITouch *touch = [[event allTouches] anyObject];  //records touch as touch object
    CGPoint location = [touch locationInView:touch.view]; //records touch's location

	double x,y;
	double radius = 24;  //radius of rotation wheel
	double radiusSquared = radius*radius; //radius squared
	double xcenter = 50; //center of rotation wheel, x coordinate
	double ycenter = 252; //center of rotation wheel, y coordinate
	
	//if location of a touch is in the area of the rotation wheel, update the 
	//rotation wheel
	if(location.x > 22 && location.x < 80 && location.y > 226 && location.y < 285)
	{
		
		//code to approximate the closest point on the rotation wheel to the point
		//where the user touched the screen (they usually will not touch the 
		//rotation wheel right on so an approximation is necessary:
		
		if(location.y < ycenter-radius)
			location.y = ycenter-radius;
		else if (location.y > ycenter+radius )
			location.y = ycenter+radius ;
		
		if(location.x < xcenter-radius)
			location.x = xcenter-radius;
		else if (location.x > xcenter+radius )
			location.x = xcenter+radius ;
		
		if(location.y >= ycenter)
			y = sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		else
		{
			y = -sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		}
		
		y = (y + location.y)/2.0;
		//NSLog(@"inter2 Y: %f",y);
		
		if(location.x >= xcenter)
			x = sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;
		else
			x = -sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;
		
		//rotation ball is moved to the approximation of the closest point on the
		//rotation wheel to the point where to user actually touched the screen
		rotationBall.center = CGPointMake(x,y); 
		
		//shipDirection (used for ship rotation and firing direction) is updated
		shipDirectionX = (x - xcenter);
		shipDirectionY = (y - ycenter);
		
		
		// get the radian angle of rotation (0 <-> 2 pi) based on point of contact with the wheel	
		CGFloat rotationAngle = atan2( shipDirectionY,shipDirectionX) + M_PI_2;
		[ship rotate: rotationAngle];

	}
	
    //---get all touches on the screen---
	/*
	 NSSet *allTouches = [event allTouches];
	 
	 
	 switch ([allTouches count])
	 {
	 //---single touch---
	 case 1: {
	 //---get info of the touch---
	 UITouch *touch = [[allTouches allObjects] objectAtIndex:0];
	 
	 //---compare the touches---
	 switch ([touch tapCount])
	 {
	 //---single tap---
	 case 1: {
	 
	 } break;
	 //---double tap---	
	 case 2: {	
	 
	 } break;	
	 }
	 
	 }  break;	
	 
	 }	
	 */
}

/*This function is called when a finger is dragged on the screen
 */
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
	
    UITouch *touch = [[event allTouches] anyObject];  //records touch as touch object
    CGPoint location = [touch locationInView:touch.view]; //records touch's location
    //NSLog(@"X: %f",location.x);
    //NSLog(@"Y: %f",location.y);
	
	
	double x,y;
	double radius = 24;  //radius of rotation wheel
	double radiusSquared = radius*radius; //radius squared
	double xcenter = 50; //center of rotation wheel, x coordinate
	double ycenter = 252; //center of rotation wheel, y coordinate
	
	//if location of a touch is in the area of the rotation wheel, update the 
	//rotation wheel
	if(location.x > 22 && location.x < 80 && location.y > 226 && location.y < 285)
	{
		
		//code to approximate the closest point on the rotation wheel to the point
		//where the user touched the screen (they usually will not touch the 
		//rotation wheel right on so an approximation is necessary:
		
		if(location.y < ycenter-radius)
			location.y = ycenter-radius;
		else if (location.y > ycenter+radius )
			location.y = ycenter+radius ;
		
		if(location.x < xcenter-radius)
			location.x = xcenter-radius;
		else if (location.x > xcenter+radius )
			location.x = xcenter+radius ;
		
		if(location.y >= ycenter)
			y = sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		else
		{
			y = -sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		}
		
		y = (y + location.y) / 2.0;
		
		if(location.x >= xcenter)
			x = sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;
		else
			x = -sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;

		//rotation ball is moved to the approximation of the closest point on the
		//rotation wheel to the point where to user actually touched the screen
		rotationBall.center = CGPointMake(x,y); 
		
		//shipDirection (used for ship rotation and firing direction) is updated
		shipDirectionX = (x - xcenter);
		shipDirectionY = (y - ycenter);
		
		CGFloat rotationAngle = atan2( shipDirectionY,shipDirectionX) + M_PI_2;
		[ship rotate: rotationAngle];		
	}
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
	//NSLog(@"touchesEnded");
}



// override to allow orientations other than the default portrait orientation
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{
    // return YES for supported orientations
    return UIInterfaceOrientationIsLandscape(interfaceOrientation);
}

- (void)didReceiveMemoryWarning {
	// Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];
	
	// Release any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload {
	// Release any retained subviews of the main view.
	// e.g. self.myOutlet = nil;
}

// release all created objects
- (void)dealloc {
	[ship release];
	[question release];
    [super dealloc];
}


@end
