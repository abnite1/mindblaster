//
//  GameScreenController.m
//  MindBlaster
//
//  Created by Steven Verner on 2/21/10.
//  Copyright 2010 __MyCompanyName__. All rights reserved.
//

#import "GameScreenController.h"
#import "GameOverScreenController.h"
#import "HelpScreenController.h"
#import "Ball.h"

@implementation GameScreenController

@class asteroidClass;

@synthesize ship;

@synthesize asteroid0, asteroid1, asteroid2, asteroid3, asteroid4, asteroid5, asteroid6, asteroid7, asteroid8, asteroid9;
@synthesize asteroids;  //this is the vector which will hold all of the above asteroid objects

@synthesize rotationBall;

@synthesize bullet0, bullet1, bullet2, bullet3, bullet4, bullet5;
@synthesize bullets; //this is the vector which will hold all of the above bullet objects

@synthesize question; 
@synthesize solution0,solution1,solution2,solution3,solution4,solution5;
@synthesize solutions; //this is the vector which will hold all of the above solution objects

@synthesize scoreLabel;

// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
- (void)viewDidLoad {
	
	UILabel *tempSolution;
	int i;  //used as a counter 
	int firstOperand, secondOperand, wrongAnswer;

	score = 0;  //player starts the game with a score of 0.

	//first two operands of question are generated by the rand() random number generator
	srand(clock());			//random number generator is initialized by the clock
	firstOperand = rand()%10;	
	secondOperand = rand()%10;
		
	//question string is generated and displayed from the two previously randomly generated operands
	NSString *InputString = [[NSString alloc] initWithFormat:@"%d + %d = ??", firstOperand, secondOperand];
	[question setText:InputString];
	[InputString release];
	
	//allocate memory for an asteroidClass object to the previously initialized asteroidClass object, asteroidDetailsTemp
	asteroidDetailsTemp = [[asteroidClass alloc] init];
	
	//values used to describe the direction the ship is facing, derived from the rotation wheel
	shipDirectionX = 0;  
	shipDirectionY = -15;
	//NSLog(@"Post load:   shipX = %f,   shipY = %f", shipDirectionX, shipDirectionY);
	
	//incrementor which denotes the next bullet to be fired, the 0th bullet is fired first
	bulletsFired = 0;
	
	//define image arrays to hold the their respective images (which are pre-assigned in the interface builder)
	asteroids = [[NSMutableArray alloc] initWithObjects: asteroid0,asteroid1,asteroid2,asteroid3,asteroid4,asteroid5,asteroid6,asteroid7,asteroid8,asteroid9,nil];
	bullets = [[NSMutableArray alloc] initWithObjects: bullet0,bullet1,bullet2,bullet3,bullet4,bullet5,nil];
	solutions = [[NSMutableArray alloc] initWithObjects: solution0,solution1,solution2,solution3,solution4,solution5];
	
	//sets the initial movement vectors
	for(i = 0; i<10; i++)
	{
		do{
			[asteroidDetailsTemp setAsteroidDirection: (rand()%30)/5  -3 :(rand()%30)/5 -3];
			if(i==0)
				[asteroidDetailsTemp setAsteroidType:0];
			else if(i<6)
				[asteroidDetailsTemp setAsteroidType:1];
			else 
				[asteroidDetailsTemp setAsteroidType:2];
		}while( [asteroidDetailsTemp getAsteroidDirection].x ==0 || [asteroidDetailsTemp getAsteroidDirection].y ==0 );
			
		asteroidDetails[i] = *asteroidDetailsTemp;
		NSLog(@"INIT asteroidType = %d", [asteroidDetailsTemp getAsteroidType]);
	}


	
	UIImageView *tempBullet;  //temperary UIImageView allows manipulation of the elements of the bullets array
	for(i = 0; i < 6;  i++)
	{
		tempBullet = [bullets objectAtIndex:i];
		tempBullet.center = CGPointMake(0,500); //set all bullets starting location as off-screen so they don't destroy any asteroids yet
	}
	[NSTimer scheduledTimerWithTimeInterval:0.05 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];
	
	//set the initial value of the solution asteroid
	tempSolution = [solutions objectAtIndex:0];
	InputString = [[NSString alloc] initWithFormat:@"%d", (firstOperand + secondOperand) ];
	[tempSolution setText:InputString];
	
	//sets all the incorrect solution asteroids to have random values between (firstOperand + 1) and (firstOperand + 1 + secondOperand +3)
	for(i = 1; i < 6; i++)
	{
		 
		
		do{
			wrongAnswer = (firstOperand + 1 + rand()%(secondOperand + 3));
			
			}while(wrongAnswer== (firstOperand + secondOperand));  
		//a incorrect solution asteroid is not allowed to have the value of the correct solution
			
		tempSolution = [solutions objectAtIndex:i];
		InputString = [[NSString alloc] initWithFormat:@"%d", wrongAnswer];
		[tempSolution setText:InputString];
	}
	
    [super viewDidLoad];
}


-(IBAction) FireButton{
	UIImageView *tempBullet; //temperary UIImageView allows manipulation of the elements of the asteroids array
	
	tempBullet = [bullets objectAtIndex:bulletsFired]; 
	//assigns element of bullets array to tempBullet to allow manipulation of that element
	
	//sets the bullet being fired's movement vector to the vector defined by the direction in which the ship is pointing
	bulletPos[bulletsFired] = CGPointMake(shipDirectionX,shipDirectionY); 

	tempBullet.center = CGPointMake(242,167);
	tempBullet.hidden = NO; 
	
	if(bulletsFired == 5)   //there are only six bullets so once all 6 have been fired start at 0 again
		bulletsFired = 0;
	else
		bulletsFired++;
}

//this function is called every 0.05 seconds, and updates the game screen
-(void) onTimer {

	int asteroidXSize = 32;
	int asteroidYSize = 30;
	int wrongAnswer;
	
	UIImageView *tempAsteroid;
	UIImageView *tempBullet;
	UILabel *tempSolution;
	
	int i =0;	//used as a counter in loops
	int i2 = 0; //used as a counter in loops
	int i3 = 0; //used as a counter in loops
	
	int firstOperand, secondOperand;
	
	
	//updates asteroid movement for each of the 10 asteroids, 0-9
	for( i = 0; i <= 9; i++)
	{
		tempAsteroid = [asteroids objectAtIndex:i];
		*asteroidDetailsTemp = asteroidDetails[i];
		//CGPoint asteroidDirection = [asteroidDetailsTemp getAsteroidPoint]
		
		//moves asteroid
		tempAsteroid.center = CGPointMake(tempAsteroid.center.x+ [asteroidDetailsTemp getAsteroidDirection].x,tempAsteroid.center.y+[asteroidDetailsTemp getAsteroidDirection].y);
		
		//if asteroid is either a correct solution asteroid or an incorrect solution asteroid move its solution label along with the asteroid
		if(i<6)  
		{
			tempSolution = [solutions objectAtIndex:i];
			tempSolution.center = tempAsteroid.center;
		}
		
		//bounces asteroid if asteroid hits left or right of screen
		if( (tempAsteroid.center.x > 480 -asteroidXSize/2 && ([asteroidDetailsTemp getAsteroidDirection].x > 0) )
		   || ( tempAsteroid.center.x < (0 +asteroidXSize/2)   && ([asteroidDetailsTemp getAsteroidDirection].x < 0)) )
		{
			[asteroidDetailsTemp setAsteroidDirection: -[asteroidDetailsTemp getAsteroidDirection].x :[asteroidDetailsTemp getAsteroidDirection].y];
		}
		//bounces asteroid if asteroid hits top or bottom of screen
		if( (tempAsteroid.center.y > 293 -asteroidYSize/2  && [asteroidDetailsTemp getAsteroidDirection].y > 0)
		   || (  tempAsteroid.center.y < (0 +asteroidYSize/2)  && [asteroidDetailsTemp getAsteroidDirection].y < 0) )
		{
			[asteroidDetailsTemp setAsteroidDirection: [asteroidDetailsTemp getAsteroidDirection].x :-[asteroidDetailsTemp getAsteroidDirection].y];
		}
		asteroidDetails[i] = *asteroidDetailsTemp;
	}
	
	//updates the bullet movement for each of the 6 bullets and checks for collisions with asteroids 
	//in which case both bullet and asteroid are destroyed
	for( i = 0; i <= 5; i++)
	{

		tempBullet = [bullets objectAtIndex:i];
		
		//moves bullet
		tempBullet.center = CGPointMake(tempBullet.center.x+bulletPos[i].x,tempBullet.center.y+bulletPos[i].y);
		
		//if bullet is off-screen then destroy the bullet by setting its movement to 0 and setting its location to 0,500, far off screen,
		//and finally hiding the bullet
		if( (tempBullet.center.x > 486 )|| ( tempBullet.center.x < -6 ) || (tempBullet.center.y > 300 )|| ( tempBullet.center.y < -6 ))
		{
			bulletPos[i].x = 0;
			bulletPos[i].y = 0;
			tempBullet.center = CGPointMake(0,500);
			tempBullet.hidden = YES;
		}
		
		//checks if the current bullet has collided with any of the 10 asteroids on the screen
		for( i2 = 0; i2 <= 9; i2++)
		{
			tempAsteroid = [asteroids objectAtIndex:i2];
			
			//if there is a collision then destroy both asteroid and bullet, hide the bullet and move it off screen and
			//move the asteroid to just above and to the left of the screen so it can move back into the screen area
			//as a new asteroid
			if(  ((tempBullet.center.x < tempAsteroid.center.x + 20) && (tempBullet.center.x > tempAsteroid.center.x - 20))
			     &&((tempBullet.center.y < tempAsteroid.center.y + 20) && (tempBullet.center.y > tempAsteroid.center.y - 20)) )
			{
				tempAsteroid.center = CGPointMake(-10,-10);
				tempBullet.center = CGPointMake(0,500);
				tempBullet.hidden = YES;
				bulletPos[i] = CGPointMake(0,0);
				
				//if([asteroidDetailsTemp getAsteroidType]  ==0)  //correct score asteroid is shot
				if(i2==0)
				{
					score+=10;
					tempSolution = [solutions objectAtIndex:i2];
					tempSolution.center = tempAsteroid.center; 
					
					firstOperand = rand()%10;	
					secondOperand = rand()%10;
					
					//question string is generated and displayed from the two previously randomly generated operands
					NSString *InputString = [[NSString alloc] initWithFormat:@"%d + %d = ??", firstOperand, secondOperand];
					[question setText:InputString];
					[InputString release];
					
					InputString = [[NSString alloc] initWithFormat:@"%d", (firstOperand + secondOperand) ];
					[tempSolution setText:InputString];
					[InputString release];
					
					InputString = [[NSString alloc] initWithFormat:@"Score: %d", score ];
					[scoreLabel setText:InputString];		
					NSLog(@"CORRECT:    input string = %@", InputString);
					NSLog(@"INIT asteroidType = %d", [asteroidDetailsTemp getAsteroidType]);
					NSLog(@"score = %d", score);
					
					
					for(i3 = 1; i3 < 6; i3++)
					{
						do{
							wrongAnswer = (firstOperand + 1 + rand()%(secondOperand + 3));
							
						}while(wrongAnswer== (firstOperand + secondOperand));  
						//a incorrect solution asteroid is not allowed to have the value of the correct solution
						
						tempSolution = [solutions objectAtIndex:i3];
						InputString = [[NSString alloc] initWithFormat:@"%d", wrongAnswer];
						[tempSolution setText:InputString];
						
						tempAsteroid = [asteroids objectAtIndex:i3];
						tempAsteroid.center = CGPointMake( rand()%500-50, rand()%300-20 );
						
					}
					
					break;
				}
				//else if( [asteroidDetailsTemp getAsteroidType]  == 1 ) //incorrect score asteroid is shot
				else if(i2 <6)
				{
					tempSolution = [solutions objectAtIndex:i2];
					tempSolution.center = tempAsteroid.center; 
					score-=2;
					NSString *InputString = [[NSString alloc] initWithFormat:@"Score: %d", score ];
					NSLog(@"WRONG:     input string = %@", InputString);
					NSLog(@"INIT asteroidType = %d", [asteroidDetailsTemp getAsteroidType]);
					NSLog(@"score = %d", score);
					[scoreLabel setText:InputString];					
				}
				else	//blank asteroid is shot
				{
					score++;
					
					NSString *InputString = [[NSString alloc] initWithFormat:@"Score: %d", score ];
					[scoreLabel setText:InputString];
					NSLog(@"BLANK:    input string = %@", InputString);
					NSLog(@"INIT asteroidType = %d", [asteroidDetailsTemp getAsteroidType]);
					NSLog(@"score = %d", score);
				}
					
			}
		}
	}
	
}

-(IBAction) HelpScreen
{
	// Navigation logic may go here -- for example, create and push another view controller.
	HelpScreenController *helpView = [[HelpScreenController alloc] initWithNibName:@"HelpScreenController" bundle:nil];
	[self.navigationController pushViewController:helpView animated:YES];
	[helpView release];
}
-(IBAction) NextScreen
{
	// Navigation logic may go here -- for example, create and push another view controller.
	GameOverScreenController *gamesOverScreenView = [[GameOverScreenController alloc] initWithNibName:@"GameOverScreenController" bundle:nil];
	[self.navigationController pushViewController:gamesOverScreenView animated:YES];
	[gamesOverScreenView release];
}

// rotate ship according to rotation wheel angle
-(IBAction) rotateByAngle:(CGFloat)angle {
	ship.transform = CGAffineTransformMakeRotation(angle);
}


/*This function is called when a touch on the screen is first detected
 */
-(void) touchesBegan: (NSSet *) touches withEvent: (UIEvent *) event {
	
    UITouch *touch = [[event allTouches] anyObject];  //records touch as touch object
    CGPoint location = [touch locationInView:touch.view]; //records touch's location

	double x,y;
	double radius = 24;  //radius of rotation wheel
	double radiusSquared = radius*radius; //radius squared
	double xcenter = 50; //center of rotation wheel, x coordinate
	double ycenter = 252; //center of rotation wheel, y coordinate
	
	//if location of a touch is in the area of the rotation wheel, update the 
	//rotation wheel
	if(location.x>22 && location.x<80 && location.y>226 && location.y<285)
	{
		
		//code to approximate the closest point on the rotation wheel to the point
		//where the user touched the screen (they usually will not touch the 
		//rotation wheel right on so an approximation is necessary:
		
		if(location.y < ycenter-radius)
			location.y = ycenter-radius;
		else if (location.y > ycenter+radius )
			location.y = ycenter+radius ;
		
		if(location.x < xcenter-radius)
			location.x = xcenter-radius;
		else if (location.x > xcenter+radius )
			location.x = xcenter+radius ;
		
		if(location.y >= ycenter)
			y = sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		else
		{
			y = -sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		}
		
		y = (y + location.y)/2.0;
		//NSLog(@"inter2 Y: %f",y);
		
		if(location.x >= xcenter)
			x = sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;
		else
			x = -sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;
		
		//rotation ball is moved to the approximation of the closest point on the
		//rotation wheel to the point where to user actually touched the screen
		rotationBall.center = CGPointMake(x,y); 
		
		//shipDirection (used for ship rotation and firing direction) is updated
		shipDirectionX = (x - xcenter);
		shipDirectionY = (y - ycenter);
		
		
		// get the radian angle of rotation (0 <-> 2 pi) based on point of contact with the wheel
		//CGPoint arcTop = CGPointMake(xcenter, ycenter - radius);	// point of reference for angle formula
		//CGFloat rotationAngle =  2 * atan2(location.y - arcTop.y, location.x - arcTop.x);
		//[self rotateByAngle: rotationAngle];		
		CGFloat rotationAngle = atan2( shipDirectionY,shipDirectionX) + 3.14159/2;
		[self rotateByAngle: rotationAngle];

	}
	
    //---get all touches on the screen---
	/*
	 NSSet *allTouches = [event allTouches];
	 
	 
	 switch ([allTouches count])
	 {
	 //---single touch---
	 case 1: {
	 //---get info of the touch---
	 UITouch *touch = [[allTouches allObjects] objectAtIndex:0];
	 
	 //---compare the touches---
	 switch ([touch tapCount])
	 {
	 //---single tap---
	 case 1: {
	 
	 } break;
	 //---double tap---	
	 case 2: {	
	 
	 } break;	
	 }
	 
	 }  break;	
	 
	 }	
	 */
}

/*This function is called when a finger is dragged on the screen
 */
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
	
    UITouch *touch = [[event allTouches] anyObject];  //records touch as touch object
    CGPoint location = [touch locationInView:touch.view]; //records touch's location
    //NSLog(@"X: %f",location.x);
    //NSLog(@"Y: %f",location.y);
	
	
	double x,y;
	double radius = 24;  //radius of rotation wheel
	double radiusSquared = radius*radius; //radius squared
	double xcenter = 50; //center of rotation wheel, x coordinate
	double ycenter = 252; //center of rotation wheel, y coordinate
	
	//if location of a touch is in the area of the rotation wheel, update the 
	//rotation wheel
	if(location.x>22 && location.x<80 && location.y>226 && location.y<285)
	{
		
		//code to approximate the closest point on the rotation wheel to the point
		//where the user touched the screen (they usually will not touch the 
		//rotation wheel right on so an approximation is necessary:
		
		if(location.y < ycenter-radius)
			location.y = ycenter-radius;
		else if (location.y > ycenter+radius )
			location.y = ycenter+radius ;
		
		if(location.x < xcenter-radius)
			location.x = xcenter-radius;
		else if (location.x > xcenter+radius )
			location.x = xcenter+radius ;
		
		if(location.y >= ycenter)
			y = sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		else
		{
			y = -sqrt( radiusSquared - (xcenter- location.x )*(xcenter- location.x ) ) + ycenter; 
		}
		
		y = (y + location.y)/2.0;
		
		if(location.x >= xcenter)
			x = sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;
		else
			x = -sqrt(radiusSquared - (ycenter - y)*(ycenter - y) ) + xcenter;

		//rotation ball is moved to the approximation of the closest point on the
		//rotation wheel to the point where to user actually touched the screen
		rotationBall.center = CGPointMake(x,y); 
		
		//shipDirection (used for ship rotation and firing direction) is updated
		shipDirectionX = (x - xcenter);
		shipDirectionY = (y - ycenter);
		
		CGFloat rotationAngle = atan2( shipDirectionY,shipDirectionX) + 3.14159/2;
		[self rotateByAngle: rotationAngle];		
	}
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
	//NSLog(@"touchesEnded");
}



// override to allow orientations other than the default portrait orientation
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{
    // return YES for supported orientations
    return UIInterfaceOrientationIsLandscape(interfaceOrientation);
}

- (void)didReceiveMemoryWarning {
	// Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];
	
	// Release any cached data, images, etc that aren't in use.
}

- (void)viewDidUnload {
	// Release any retained subviews of the main view.
	// e.g. self.myOutlet = nil;
}


- (void)dealloc {
    [super dealloc];
}


@end
